#!/usr/bin/env python3


# TODO:
#   upgrade pyserial to v3 and change commands marked #v3
#   Implement menu options
#   Test CTS control
#   Test data packet sending
#   Need to store the packet sent to resend if asked
#   Add in the help functionality
#
# BUGS
#   conn in the try except routine at the end is not defined!


import RPi.GPIO as GPIO
import serial
import logging
import sys, tty, termios
import datetime

import PacketGenerator


BAUDRATE = 9600         # The speed of the comms
PORT = "/dev/serial0"   # The port being used for the comms
TIMEOUT = 1             # The maximum time allowed to receive a message
GPIO_CTS = 11           # The CTS line, also known as GPIO17

LOG_LVL = logging.DEBUG

def SetupLogging():
    """
    Setup the logger and the various settings
    """
    # create logger
    logger = logging.getLogger(__name__ + ".log")
    logger.setLevel(logging.DEBUG)

    # create console handler and set level to Error
    ch = logging.StreamHandler()
    ch.setLevel(logging.ERROR)
    
    # create file handler which logs even debug messages
    fh = logging.FileHandler(__name__ + ".log")
    fh.setLevel(LOG_LVL)

    # create formatter
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')

    # add formatter to ch and fh
    ch.setFormatter(formatter)
    fh.setFormatter(formatter)

    # add ch to logger
    logger.addHandler(ch)
    logger.addHandler(fh)
    return logger
    
def SerialSetup():
    """ 
    Setup the serial connection for the EWC, using serial
    Setup the GPIO port for the CTS line
    """
    # set the GPIO pin for the CTS line output
    GPIO.setmode(GPIO.BOARD)
    GPIO.setup(GPIO_CTS, GPIO.OUT)
    
    # open the serial port and set the speed accordingly
    fd = serial.Serial(PORT, BAUDRATE, timeout = TIMEOUT)

    # clear the serial buffer of any left over data
    #fd.reset_output_buffer()       #v3
    fd.flushOutput()
    
    if fd.isOpen():
        # if serial is setup and the opened channel is greater than zero (zero = fail)
        print ("PI setup complete on channel %s" % fd)
        logger.info("PI setup complete on channel %s" % fd)
    else:
        print ("Unable to Setup communications")
        logger.error ("Unable to Setup communications")
        sys.exit()
        
    return fd

def CTSControl(state="SWITCH"):
    """
    Set the state of the CTS line
    possible values for the state are
       HIGH     set it high
       LOW      set it low
       SWITCH   (default)
    """
    if state.upper() == "HIGH":
        GPIO.output(GPIO_CTS, GPIO.HIGH)
    elif state.upper() == "LOW":
        GPIO.output(GPIO_CTS, GPIO.LOW)
    elif state.upper() == "SWITCH":
        GPIO.output(GPIO_CTS, not(GPIO.input(GPIO_CTS)))
    else:
        print("CTS Control State requested outside of range")
    return

def WriteDataBinary(fd,send,cts=True):
    # This routine will take the given data and write it to the serial port
    # returns the data length or 0 indicating fail
    # if cts is False, doesn't control the cts line

    try:
        if cts:
            CTSControl("LOW")
        ans = fd.write(send)
        logging.info("Message >%s< written to LoRa module with response :%s" % (send, ans))
        if cts:
            CTSControl("HIGH")
    except Exception as e:
        logging.warning("Message >%s< sent as >%a< FAILED" % (message, send))
        ans = 0
    return ans

def GenerateGoodPacket():
    """
    Generates and returns a single packet
    EE SS MM HH DD MT YY UU UU UU UU UC UC UC UC SCR SCR SCR SCR ECR ECR ECR ECR FC FC FT FT
    0  1  2  3  4  5  6  7  8  9  10 11 12 13 14 15  16  17  18  19  20  21  22  23 24 25 26
    """
    # generated by the PacketGenerator script
    return PacketGenerator.GeneratePacket()

def GenerateErrorPacket(error):
    """
    Generates a packet with an error code first
    """
    # generated by the PacketGenerator script
    return PacketGenerator.GeneratePacket(False,error)
    
def Menu_ControlCTS(fd):
    """
    Allow the user to manually, or automatically toggle the CTS line
    """
    print("\nControl the CTS Line\n")
    choice = input("Choose (H)igh, (L)ow, (T)oggle or (R)epeatably Toggle:")
    if choice.upper() =="H":
        CTSControl("HIGH")
        print("CTS Now High")
    elif choice.upper() =="L":
        CTSControl("LOW")
        print("CTS Now Low")
    elif choice.upper() =="T":
        CTSControl("SWITCH")
        print("CTS Switched")
    elif choice.upper() =="R":
        speed =0
        while speed ==0:
            speed = input("Set time period (in seconds)")
            if speed.isdigit == False:
                print("Enter a number please")
                speed = 0
            elif speed < 0:
                print("Only positive numbers please")
                speed = 0
        print("CTRL-C to exit")
        try:
            while True:
                # in the loop waiting for the CTRL-C key press to exit
                starttime = datetime.datetime.now()
                endtime = starttime + datetime.timedelta(seconds=speed)
                while endtime > datetime.datetime.now():
                    print ("\r.", end="")
                CTSControl("SWITCH")
                print("Switched")
        except KeyboardInterrupt:
            print("Completed")
    else:
        print("Unknown Option")
    return

def Menu_SendSinglePacket(fd):
    """
    Send a single packet to the EWC
    Controls the CTS line automatically
    """
    print("Sending a packet")
    # Get a packet
    to_send = GenerateGoodPacket()
    
    # Send a packet
    ans = WriteDataBinary(fd,to_Send)
    if ans > 0:
        print("Packet Sent: %s" % to_send)
    return

def Menu_SendRepeatingPacket(fd):
    """
    Allows the user to determine the speed of messaging and then sends a packet repeatably
    Controls the CTS line
    """

    speed =0
    while speed ==0:
        speed = input("Set time period (in seconds)")
        if speed.isdigit == False:
            print("Enter a number please")
            speed = 0
        elif speed < 0:
            print("Only positive numbers please")
            speed = 0
    print("CTRL-C to exit")
    try:
        while True:
            # in the loop waiting for the CTRL-C key press to exit
            starttime = datetime.datetime.now()
            endtime = starttime + datetime.timedelta(seconds=speed)
            while endtime > datetime.datetime.now():
                print ("\r.", end="")
            print("Sending a packet")
            # Get a packet
            to_send = GenerateGoodPacket()
            
            # Send a packet
            ans = WriteDataBinary(fd,to_Send)
            if ans > 0:
                print("Packet Sent: %s" % to_send)
    except KeyboardInterrupt:
        print("Completed")  
    return

def Menu_SendErrorPacket(fd):
    """
    Allow the user to select an error code and then send a single packet with the error code
    Controls the CTS line
    """
    err =0
    while err ==0:
        err = input("Select Error Code (1 - 15)")
        if err.isdigit == False:
            print("Enter a number please")
            err = 0
        elif err < 0 or err > 15:
            print("Only numbers in the range 1 to 15")
            err = 0
    print("Sending a packet")
    # Get a packet
    to_send = GenerateGoodPacket(False, err)
    
    # Send a packet
    ans = WriteDataBinary(fd,to_Send)
    if ans > 0:
        print("Packet Sent: %s" % to_send)
    return

def Menu_IoTReply(fd):
    """
    Respond to the IoT commands automatically
    """
    print("Not Yet Implemented")
    return

    
def HelpText():
    """
    Display the list of commands possible for the program
    """
    print("Menu Options")
    print("------------\n\n")
    print("1 - Control CTS")
    print("2 - Send Datalog Packet")
    print("3 - Send Datalog Packet every x seconds")
    print("4 - Send Datalog Packet with error ee")
    print("0 - Respond to IoT")
    print("h - Show this help")
    print("e - exit")
    return
    
def SplashScreen():
    print("***********************************************")
    print("*        Bostin Technology Emulator           *")
    print("*                                             *")
    print("*       in association with eWater Pay        *")
    print("*                                             *")
    print("*                EWC Emulator                 *")
    print("***********************************************\n")
    return
    
def main():
    
    SplashScreen()
    
    log = SetupLogging()
    log.info("Application Started")
    conn = SerialSetup()
    
    HelpText()
    choice = ""
    while choice.upper() != "E":
        choice = input("Select Menu Option:")
        if choice == "1":
            Menu_ControlCTS(conn)
        elif choice == "2":
            Menu_SendSinglePacket(conn)
        elif choice == "3":
            Menu_SendRepeatingPacket(conn)
        elif choice == "4":
            Menu_SendErrorPacket(conn)
        elif choice =="0":
            Menu_IoTReply(conn)
        elif choice.upper() =="E":
            pritn("Leaving")
            exit()
        else:
            print("Unknown Option")
    print("got here!")
    return

if __name__ == '__main__':

    conn = ""
    try:
        main()
    
    except:
        if conn:
            conn.close()
        GPIO.cleanup()
        sys.exit()



